## 函数简介

【导入】：页面调用多部分重复代码时，例如：打印多个99乘法表。

【作用】：实现`代码复用`提高开发效率。

【函数】：（官方）function，是被设计为`执行特定任务的代码块`。

【说明】：函数可以把具有相同或相似逻辑的代码“包裹”起来，通过函数调用执行这些被“包裹“的代码逻辑，这么做的优势是有利于`精简代码，方便复用`。

------

## 创建函数的3种方法

### 声明函数

方法：以function关键字声明的方式创建函数。

语法：`function 函数名(形参列表) {函数体 return}`

### 函数表达式赋值

方法：函数表达式以赋值的方式创建

语法：`let getSum = function [funName]\(形参列表) {...}`

特点：

- 不会发生声明提前
- 若有函数名，会被覆盖

### new创建

方法：使用new的构造函数创建，但几乎不用

语法：let fun = new Function('形参1', '形参2', ..., '函数体&返回值')

------

## 函数属性

### 函数命令规范

要求：

- 和变量命名基本一致；
- 尽量使用小驼峰命名法；
- 前缀常用动词约定；

动词：

| 动词 | 含义                   |
| ---- | ---------------------- |
| can  | 判断是否可执行某个操作 |
| has  | 判断是否含有某个值     |
| is   | 判断是否为某个值       |
| get  | 获取某个值             |
| set  | 设置某个值             |
| load | 加载某些数据           |

### 参数（形参 & 实参）

参数列表：

- 传入数据列表；
- 声明这个函数需要传入的几个数据；
- 多个数据用`,`隔开；

形参：`声明函数时`写在函数名右边小括号里的参数；（形式上的参数）

实参：`调用函数时`写在函数名右边小括号里的叫实参；（实际上的参数）

注意：

- 形参可以理解为是在这个函数内声明的变量（比如num1 =  10)，实参可以理解为给这个变量赋值；
- `开发中尽量保持形参和实参个数一致`；
- 我们曾用的alert(‘警示框’);parseInt('20abc');本质上都是函数调用的传参

### 函数体

函数体：函数{}包裹的代码，叫~。

------

### 函数返回值/return

问题：函数内部是局部作用域，变量为局部变量，函数外部无法访问内部变量。

> return

return：返回值，`当外部需要访问函数数据时，用return关键字返回`。

语法：`function fun() { return 数据}`

处理：`开发中，常用变量接住函数返回值`。

示例：

```js
    function getMyResult() {
      return 20
    }

    // 开发中经常这样写
    let re = getMyResult()
```

注意：

- `return会立即中断函数执行；`（所以return后不要书写代码，写了return后也不再执行）
- `没有return，默认返回值为undefiend`
- `return可以数组对象格式返回多个值，常用对象`；

------

## 函数使用

### 函数调用

特点：

- `函数不调用，就不执行。（只声明）`
- 函数可多次调用；
- 先声明，后调用；（存在函数提升，但是建议这样写）

说明：

- 系统内置函数：已经内置写好了函数，直接调用即可；（例如：alert()，parseInt()...）

------

### 逻辑中断

逻辑中断：合理利用逻辑中断，给函数实参设置默认值。

```js
function getSum(x, y) {
    x = x || 0
    y = y || 0
    console.log(x + y)
}
getSum()//0
getSum(2, 5)//7
```



### 特殊传参

【特殊传参】：将`数组/对象`定义为形参；

【对应要求】：实参也需要以数组/对象的格式传入；

【示例】：数组传参

```js
    // 需求：求学生总分
    let arr = [99, 10, 90]
    let arr1 = [100, 100, 90]
    // 声明函数
    function getScore(arrs) {
      let sum = 0
      for (let i = 0; i < arr.length; i++) {
        sum += arrs[i]							//注意：这里循环获取的应该是形参的元素
      }
      console.log(sum)
    }

    // 调用函数（以数组传参）
    getScore(arr)
    getScore(arr1)
```

【对象传参】：

------

### 封装函数

封装：反复调用的代码就需要封装成函数，节省工作量

封装内容：

- 公式
- 操作
- 计算

常用：

- 得到N~M之间的随机数

```js
//0~1的随机数
Math.floor(Math.random() * (10 + 1))
//生成5-10的随记数
Math.floor(Math.random() * (5 + 1))	+ 5
//生成N~M之间的随记数
Math.floor(Math.random() * (M - N + 1))  + N
```









## 作用域/作用域链（**）

### 作用域

问题：循环/函数内定义了一个变量，循环外就使用不了了。

概念：通常来说，一段程序代码中所用到的变量并不总是有效和可用的，而限定这个名字的`可用性的代码范围`就是这个名字的`作用域`。作用域提高了程序逻辑的局部性，增强了程序的可靠性，减少了变量名冲突。

总结：`代码在哪个区域内可用`，这个区域叫作用域。

> 全局作用域/全局变量

全局作用域：保存在全局window对象中，任何地方都可以访问到的变量区域叫~。

全局变量：

- 概念：在全局作用域中保存的变量称为全局变量。
- 优点：共用，可反复使用；
- 缺点：易被污染，浪费内存；

> 局部作用域/局部变量

局部作用域：保存仅在函数内可使用的变量的区域；

局部变量：

- 函数作用域保存的变量称为局部变量；
- 优点：仅函数内可用，不会污染全局；且**用完就释放**，不占用内存！
- 缺点：**无法重用**；

> 块级作用域/块级变量

块级作用域：块作用域由{ }包括，if语句和for语句里面的{ }等

块级变量：{ }内有效

注意：

- var声明的变量块级外可以使用;
- `let声明的变量，产生块级作用域，{}外不可访问`；

示例：

```js
    // 块级作用域
    if (true) {
      var c = 10
    }
    if (true) {
      let d = 10
    }
    console.log(c)//10
    console.log(d)
//报错：Uncaught ReferenceError: b is not defined
```

------

说明：js和java的区别（了解）

js和java中的写法不同：

```js
for(var i = 1, sum = 0; i <= 100; i++) {
    sum += i
}
console.log(sum)
```

区别：

- js代码需要下载到浏览器执行，所以对间接性要求更高；
- 而上述代码在java中会报错(java中有块级作用域）；
- 上述用let声明在js中也会报错；

java：三级作用域（全局，函数，块），if,else,else if,do while,for等这些结构的{}在java中也是一级作用域，所以java中块级作用域的变量除了{}就不能用

------

### 作用域链/scopes

常见报错：

```js
//变量未定义
Uncaught ReferenceError: b is not defined
```

原因：

- 未声明变量
- 变量不存在
- `变量不在作用域链`

作用域链：就是变量访问原则

解释：

1. 只要是代码，就至少有一个作用域；
2. 写在函数内部的是局部作用域；
3. 如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域；
4. 根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链。

变量访问原则：`作用域链——就近原则`；

- 先从当前作用域中查找；	-++++++++++++++++
- 没有再往上一级作用域查找；
- 没找到就报错：变量is not defined；

------

## 匿名函数/function () {}

> 语法

js函数分类：

- 具名函数；
- 匿名函数；

匿名函数：定时函数时不起名称的函数叫~

使用：

- 函数表达式：将匿名函数赋值给一个变量，并且通过变量名称进行调用，我们将这个称为`函数表达式`。
- 回调函数：匿名函数做为形参；

优点：

- 节约内存：如果匿名函数不被变量引用，则使用完后会立即释放；
- 划分临时作用域；（函数内变量不会被污染）

语法：

```js
//定义
let fn = function () {
	函数体
}
//调用
fn()

//可传参
let fn = function (x, y) {
	函数体
}
//调用
fn(1, 2)
```

【应用】：dom中常用



### 匿名函数自调（***）

【优点】：防止变量污染。

【规定】：`今后所有写的js代码都写在匿名函数自调中`。

语法：3种写法，习惯用哪个就用哪个，但看到其他的要能读懂

```js
//语法
( function () { 函数体 } )()

//示例
    (function () {
      console.log('111')
    })()

    (function (x, y) {
      return x + y
    })(1, 3)
```

```js
(function () {函数体}())
```

```js
(function fn() {}())
```





应用：flexible.js（移动端rem适配）

```js
//这个js引过来就可以用了，因为是立即执行函数
(function flexible(window, document) {...})(window, document)
```

【说明】：

- 多个立即执行函数之间，必须加`；`隔开。
- `; 加在前面；（习惯上）`

> 拓展：函数参数特殊情况

【情况①】：函数调用时缺参/多参





【情况②】：arguments

代码：

```js
    function fun() {
      console.log(arguments)
      //伪数组/类数组对象：接住所有参数（只在函数内有效）
    }

    fun(1, 2, 3)
```

结果：

- arguments只在函数内生效；
- arguments是伪数组/类数组对象；
- 实参值可用arguments[i]访问；

![image-20220317084606617](C:/Users/hd/Desktop/notes/notes/img/js/image-20220317084606617.png)



【注意】：ES6后因性能考虑，严格模式下，禁用递归，也就禁用了arguments。

------



### 高阶函数

高阶函数：可以被简单理解为函数的高级应用

理解：函数以值的方式使用

分类：

- 函数表达式（赋值）
- 回调函数（传参）

------

### 函数表达式

函数表达式：与普通函数本质上是一样的，将函数当值赋给变量；

作用：

- 给匿名函数添加名称调用；
- 给有名函数添加简短自定义名调用；(原函数名被覆盖)

语法：

```js
let counter = function (x, y) {
    return x + y
}
//调用函数
let result = counter(5, 10)-
console.log(result)

    let plugin = function navigatorPlugins(plugins) {
      console.log(plugins)
    }
    plugin('Chrome')
```

------

### 回调函数/callback

回调函数：如果将函数A传递给函数B时，我们称函数A为回调函数。

简单理解：当一`个函数被当做参数来传递`给另外一个函数时，这个函数就是回调函数。

示例：

- 定时器
- replace

```js
//周期性定时器
setInterval(callback, delay)

//replace
str = str.replace(reg, callback)
```

------

## 构造函数

构造函数：专门描述一类对象统一结构的函数。

分类：

- 内置构造函数
- 自定义构造函数

### 内置构造函数

语法：`new 构造类型(形参列表)`

内容：

- new Object()
- new Array()
- new Fucntion()

### 自定义构造函数

见创建对象——自定义构造函数创建对象



## 递归函数

递归：函数自己调用自己；



出错：

- 死递归：递归无限调用自己，不停止，报错。

```js
//未捕获的测量误差:超过了最大调用堆栈大小
Uncaught RangeError: Maximum call stack size exceeded
```











## 环境变量this

lis:	this



作用：弄清楚this的指向，可以让代码更简洁。

特点：

- this就是一个对象，typeof this == obj；

> 规则：

ES5 普通函数：谁调用，this就指代谁；

箭头函数：指向外层函数 this 值，最外层为 window；

'use strict' ：严格模式下，this 不指向window，为undefined；



> 排它思想：多个对象，有且仅有1个元素变化。

解决1："干掉所有人，除了它自己"；==（for循环获得伪数组，发生单击事件时，遍历伪数组，将所有的需求清0，再给当前点击的设置）

解决2：按类名找到这个元素，移除这个元素，给点击元素添加样式。（省略写一层循环）



## null处理

null：如果一个函数有可能返回null，则使用返回值前，必须先验证其不是null值，才能使用。

原因：因为null之后，什么都不能加！

报错：强行加后，会造成程序当机。

```

```

`处理`：

例如返回数组：`共替换${arr !== null ? arr.length : 0}处`

其他同理